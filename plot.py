# -*- coding: utf-8 -*-
"""
Created on Tue Aug 19 14:31:57 2014

@author: viktor

plumy.plot - Plumy's visualization module.
 
"""

from plumy.utils import DataSelector 
from matplotlib import pyplot as plt
from matplotlib.ticker import AutoMinorLocator
import numpy as np
import scipy as sp

def plot(obj, mode='default', show_mfc_read=False, 
         show_title=True, show_legend=True):
    """
    Plot time series.
    Returns figure handle and plot title.
    
    Keyword arguments:
    obj -- SensorColumn, SensorBoard or Sensor class instance
    mode -- string, plot mode
    show_title -- bool, display Title on/off
    show_legend -- bool, display legend on/off
    
    Available modes:
    SensorColumn -- 'default', 'norm' (normalized), 'filt' (filtered)
    SensorBoard -- 'default', 'norm', 'filt', 'aio' (all-in-one), 'norm_aio', 'filt_aio', 'norm_filt'
    Sensor -- 'default', 'norm' (normalized), 'filt' (filtered), 'norm_filt'
    """
    assert isinstance(mode, str)
    assert isinstance(show_title, bool)
    assert isinstance(show_legend, bool)

    fig = plt.figure()
    title = '%s: %s %s %s %s %s' % (obj.Name, obj.Gas, obj.Location,
                                    obj.SensorVoltage, obj.FanSpeed,
                                    obj.TimeStamp)
    if show_title:
        fig.suptitle(title, fontsize=16)

    if obj.__class__.__name__ is 'SensorColumn':
        x = obj._Time  # ms

        if show_mfc_read:
            first = []
            last = []
            try:
                first.append(np.where(obj.get_mfc1_read>=100)[0][0])
                last.append(np.where(obj.get_mfc1_read>=100)[0][-1])
            except:
                pass
            try:
                first.append(np.where(obj.get_mfc2_read>=100)[0][0])
                last.append(np.where(obj.get_mfc2_read>=100)[0][-1])
            except:
                pass
            try:
                first.append(np.where(obj.get_mfc3_read>=100)[0][0])
                last.append(np.where(obj.get_mfc3_read>=100)[0][-1])
            except:
                pass

            if not first or not last:
                print 'No MFC reads present!'
                return
            else:
                first = obj._Time[min(first)]/1000
                last = obj._Time[max(last)]/1000

        if mode is 'default':
            xlim = [0, 260000]            
            ylim = [obj.get_min()[2], obj.get_max()[2]]
            
            for i in xrange(1,10):
                fig.add_subplot(3,3,i)
                board = getattr(obj, 'Board%i' % (i))
                lines = plt.plot(x, board())
            
                if i is 1 and show_legend:
                    fig.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                               'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=8,
                               mode = 'expand', ncol=8)
                
                locs, labels = plt.xticks()
                labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                
                plt.title('Board %i' % i)
                if show_mfc_read:
                    plt.axvspan(first, last,
                                facecolor= 'g', alpha = 0.5)
                plt.grid()

            plt.tight_layout()
            try:
                mng = plt.get_current_fig_manager()
                mng.window.showMaximized()
            except AttributeError:
                pass
            plt.show()
                
        elif mode is 'norm':
            xlim = [0, 260000]
            ylim = [0, 1]
            
            for i in xrange(1,10):
                fig.add_subplot(3,3,i)
                board = getattr(obj, 'Board%i' % (i))
                lines = plt.plot(x, board.get_normal)
            
                if i is 1 and show_legend:
                    fig.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                               'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=8,
                               mode = 'expand', ncol=8)
                locs, labels = plt.xticks()
                labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                plt.title('Board %i')
                if show_mfc_read:
                    plt.axvspan(first, last,
                                facecolor= 'g', alpha = 0.5)
                plt.grid()
                
            plt.tight_layout()
            try:
                mng = plt.get_current_fig_manager()
                mng.window.showMaximized()
            except AttributeError:
                pass
            plt.show()

        if mode is 'filt':

            for i in xrange(1,10):
                fig.add_subplot(3,3,i)
                board = getattr(obj, 'Board%i' % (i))
                lines = plt.plot(x, board.get_filtered, linewidth=2)
            
                if i is 1 and show_legend:
                    fig.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                               'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=8,
                               mode = 'expand', ncol=8)
                locs, labels = plt.xticks()
                labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim([0, 260000])
                plt.ylim([obj.get_min()[2], obj.get_max()[2]])
                plt.title('Board %i' % (i))
                if show_mfc_read:
                    plt.axvspan(first, last,
                                facecolor= 'g', alpha = 0.5)
                plt.grid()

            plt.tight_layout()
            try:
                mng = plt.get_current_fig_manager()
                mng.window.showMaximized()
            except AttributeError:
                pass
            plt.show()

    elif obj.__class__.__name__ is 'SensorBoard':
        x = obj._Time  # ms
        if mode is 'default':
            xlim = [0, 260000]
            ylim = [obj.get_min[1], obj.get_max[1]]
            for i in xrange(1,9):
                fig.add_subplot(2,4,i)
                sensor = getattr(obj, 'Sensor%i' % (i))
                plt.plot(x, sensor(), label= 'Sensor %i' % (i), c = 'r')
                plt.title('Sensor %i' % (i))
            
                if i is 1:
                    locs, labels = plt.xticks()
                    labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                plt.grid()

        elif mode is 'norm':
            xlim = [0, 260000]
            ylim = [0, 1]
            for i in xrange(1,9):
                fig.add_subplot(2,4,i)
                sensor = getattr(obj, 'Sensor%i' % (i))
                plt.plot(x, sensor.get_normal, label= 'Sensor %i' % (i), c = 'r')
                plt.title('Sensor %i' % (i))
            
                if i is 1:
                    locs, labels = plt.xticks()
                    labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                plt.grid()
                
        elif mode is 'filt':
            xlim = [0, 260000]
            ylim = [obj.get_min[1], obj.get_max[1]]
            for i in xrange(1,9):
                fig.add_subplot(2,4,i)
                sensor = getattr(obj, 'Sensor%i' % (i))
                plt.plot(x, sensor.get_filtered, label= 'Sensor %i' % (i), c = 'r')
                plt.title('Sensor %i' % (i))
            
                if i is 1:
                    locs, labels = plt.xticks()
                    labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                plt.grid()
                
        elif mode is 'aio':
            lines = plt.plot(x, obj())
            if show_legend:
                plt.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                           'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=6)
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([obj.get_min[1], obj.get_max[1]])
            if show_title:
                plt.title('All raw Sensors')
            plt.grid()
            
        elif mode in ['aio_norm','norm_aio']:
            lines = plt.plot(x, obj.get_normal)
            if show_legend:
                plt.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                           'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=6)
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([0,1])
            if show_title:
                plt.title('All Sensors normalized')
            plt.grid()
            
        elif mode in ['aio_filt', 'filt_aio']:
            lines = plt.plot(x, obj.get_filtered, linewidth=2)
            if show_legend:
                plt.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                           'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=6)
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([obj.get_min[1], obj.get_max[1]])
            if show_title:            
                plt.title('All Sensors Low-Pass filtered')
            plt.grid()
            
        elif mode in ['norm_filt','filt_norm']:
            y = obj.normalize(obj.get_filtered, obj.get_min[1], obj.get_max[1])
            lines = plt.plot(x, y, linewidth=2)
            if show_legend:
                plt.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                           'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=6)
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([0, 1])
            if show_title:            
                plt.title('All Sensors normalized & Low-Pass filtered')
            plt.grid()
            
        else:
            print 'No Option %s found!' % mode

    elif obj.__class__.__name__ is 'Sensor':
        x = obj._Time  # ms
        if mode is 'default':
            plt.plot(x, obj(), c = 'r')
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([obj.get_min, obj.get_max])
            plt.grid()
        elif mode is 'norm':
            plt.plot(x, obj.get_normal, c = 'r')
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([0,1])
            plt.grid()
        elif mode is 'filt':
            plt.plot(x, obj.get_filtered, c = 'r')
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([obj.get_min, obj.get_max])
            plt.grid()
        elif mode in ['norm_filt','filt_norm']:
            y = obj.normalize(obj.get_filtered, obj.get_min, obj.get_max)
            plt.plot(x, y, c = 'r')
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([0,1])
            plt.grid()
        else:
            print 'No Option %s found!' % mode
    return fig, title
    
def activity(ds, **kwargs):
    """
    Plot testbed (all 6 Columns) activity.
    Returns figure & colorbar handle.
    
    Keyword arguments:
    gas -- int of range(1,12), gas name identifier
    voltage -- int of range(1,6) , sensor voltage identifier
    speed -- int of range(1,4) , fan speed identifier
    trial -- int of range(1,21), experiment repetitions
    mode -- string, activity criterion
    show_labels -- bool, if true, show axis labels     
    
    Available modes:
    'max' -- Use Sensor activation maxima as criterion
    'var' -- Use Sensor variability as criterion
    'fano' -- Use fano-factor (Variance/Mean) as criterion
    """
    assert isinstance(ds, DataSelector)
    
    default_gas = 10
    default_voltage = 5
    default_speed = 1
    default_trial = 1
    default_mode = 'max'
    default_labels = False;

    gas = kwargs.get('gas', default_gas)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)
    mode = kwargs.get('mode', default_mode)
    show_labels = kwargs.get('show_labels', default_labels)      
    
    assert isinstance(gas, int) and gas in range(1,12)
    assert isinstance(voltage, int) and voltage in range(1,6)
    assert isinstance(speed, int) and speed in range(1,4)
    assert isinstance(trial, int) and trial in range(1,21)
    assert mode in ['var', 'max', 'fano']
    
    col = ds.select(gas=gas, voltage=voltage, speed=speed, trial=trial)
    
    fig = plt.figure()
    gs = plt.GridSpec(9,6)
    _max = 0
    
    if mode is 'max':
        for c in col:
            if c.get_max()[2] > _max:
                _max = c.get_max()[2]
    elif mode is 'var':
        for c in col:
            if c.get_var()[2] > _max:
                _max = c.get_var()[2]
    elif mode is 'fano':
        for c in col:
            if c.get_fano()[2] > _max:
                _max = c.get_fano()[2]   
    
    for i,column in enumerate(col):
        for j,board in enumerate(column.iter_boards):
            plt.subplot(gs[j,i])
            arr = []
            for sensor in board.iter_sensors:
                if mode is 'max':
                    arr.append(sensor.get_max)
                elif mode is 'var':
                    arr.append(sensor.get_var)
                elif mode is 'fano':
                    arr.append(sensor.get_fano)
                
            arr = np.array(arr)
            arr.shape = (2,4)
            ax = plt.imshow(arr, interpolation='nearest', vmax=_max)
            plt.axis('off')
    
    fig.subplots_adjust(right=0.8)
    cbar_ax = fig.add_axes([0.85, 0.15, 0.025, 0.7])
    cb = fig.colorbar(ax, cax=cbar_ax)

    if show_labels:
        fig.text(0.415, 0.95, 'Distance from odor source', fontsize=20)
        fig.text(0.05, 0.6, 'Board number', fontsize=20, rotation=90)
        fig.text(0.93, 0.6, 'variance / mean', fontsize=20, rotation=90)
        fig.text(0.1, 0.85, '1', fontsize=16)
        fig.text(0.1, 0.76, '2', fontsize=16)
        fig.text(0.1, 0.67, '3', fontsize=16)
        fig.text(0.1, 0.58, '4', fontsize=16)
        fig.text(0.1, 0.49, '5', fontsize=16)
        fig.text(0.1, 0.40, '6', fontsize=16)
        fig.text(0.1, 0.31, '7', fontsize=16)
        fig.text(0.1, 0.22, '8', fontsize=16)
        fig.text(0.1, 0.13, '9', fontsize=16)
        fig.text(0.155, 0.05, '0.25m', fontsize=16)
        fig.text(0.275, 0.05, '0.50m', fontsize=16)
        fig.text(0.39, 0.05, '0.98m', fontsize=16)
        fig.text(0.505, 0.05, '1.18m', fontsize=16)
        fig.text(0.62, 0.05, '1.40m', fontsize=16)
        fig.text(0.735, 0.05, '1.45m', fontsize=16)    
    
    try:
        mng = plt.get_current_fig_manager()
        mng.window.showMaximized()
    except AttributeError:
        pass
    plt.show()
    return fig, cb
    
def spectral(ds, **kwargs):
    """
    Plot selected comparative frequency spectra.
    Returns figure handle(s) and plot title(s); 
    If pool-flag is true, return compiled fft data aswell. 
    
    Keyword arguments:
    gas -- int or list of range(1,12), gas name identifier
    loc -- int or list of range(1,7), column location identifier
    voltage -- int of range(1,6) , sensor voltage identifier
    speed -- int of range(1,4) , fan speed identifier
    trial -- int of range(1,21), experiment repetitions
    board -- int or list of range(1,10), board identifier
    sensor -- int or list of range(1,9), sensor identifier
    pool -- bool, if true, compile all spectra into a single plot
    win -- slice, time series selection window
    win_fcn -- string, fourier transform window function to reduce leakage
    show_title -- bool, display title on figure
    show_legend -- bool, if true, display legend
    include_invalide -- bool, include invalide sensors into analysis flag
    """
    assert isinstance(ds, DataSelector)
    
    # set default values
    default_gas = 10
    default_loc = 1
    default_voltage = 5
    default_speed = 1
    default_trial = 1
    default_board = 4
    default_sensor = 5
    default_pool = False
    default_win = slice(10000, 20000)

    # get arguments
    gas = kwargs.get('gas', default_gas)
    loc = kwargs.get('loc', default_loc)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)    
    brd = kwargs.get('board', default_board)
    snsr = kwargs.get('sensor', default_sensor)
    pool = kwargs.get('pool', default_pool)
    win = kwargs.get('win', default_win)
    win_fcn = kwargs.get('win_fcn', None)
    show_title = kwargs.get('show_title', True)
    show_legend = kwargs.get('show_legend', True)
    include_invalide = kwargs.get('include_invalide', False)
    
    # assert argument datatype 
    assert isinstance(loc, (int, list))
    assert isinstance(gas, int)
    assert isinstance(voltage, int) 
    assert isinstance(speed, int) 
    assert isinstance(trial, int) 
    assert isinstance(brd, (int, list))
    assert isinstance(snsr, (int, list))
    assert isinstance(pool, bool)
    assert isinstance(win, slice)
    assert isinstance(show_title, bool)
    assert isinstance(show_legend, bool)
    assert isinstance(win_fcn, (type(None), str))
    assert isinstance(include_invalide, bool)
    
    # cast int entries to list
    if isinstance(loc, int):
        loc = [loc]
    if isinstance(brd, int):
        brd = [brd]
    if isinstance(snsr, int):
        snsr = [snsr]
                    
    # assert argument value
    assert min(loc) > 0 and max(loc) <= 6
    assert gas in range(1,12)
    assert voltage in range(1,6)
    assert speed in range(1,4)
    assert trial in range(1,21)
    assert min(brd) > 0 and max(brd) <= 9
    assert min(snsr) > 0 and max(snsr) <= 8
    assert win.start >= 0 and win.stop <= 26000
    
    # try to construct window function
    if win_fcn is not None:
        if win_fcn in ('Hamming', 'hamming'):
            win_fcn = np.hamming(win.stop-win.start)
        elif win_fcn in ('Blackman', 'blackman'):
            win_fcn = np.blackman(win.stop-win.start)
        elif win_fcn in ('Hanning', 'hanning'):
            win_fcn = np.hanning(win.stop-win.start)
        elif win_fcn in ('Bartlett','bartlett'):
            win_fcn = np.bartlett(win.stop-win.start)
        else:
            win_fcn = None
    
    
    # select columns
    cols = ds.select(gas=gas, loc=loc, speed=speed, voltage=voltage, trial=trial)
    
    rgb_tuples = plt.cm.spectral(np.arange(265)) # generate rgb color values
    lines = []
    b, a = sp.signal.butter(2, (float(0.01)/50, 1/float(50)), 'bandpass')
    
    if pool:
        # allocate fft data storage
        fft_list = np.zeros([len(loc),len(brd)*len(snsr)+1,(win.stop-win.start)/2])
        cnt = 0
    else:
        handle_list = []
        title_list = []
        
    for bo in brd:
        for se in snsr:
            
            if not pool:
                # generate individual figure
                fig = plt.figure()
                handle_list.append(fig)
                title = '%s L1-L6 %s %s %s Board %i, Sensor %i' % (cols[0].Gas, cols[0].SensorVoltage,
                                       cols[0].FanSpeed, cols[0].TimeStamp, bo, se)
                title_list.append(title)
                if show_title:
                    fig.suptitle(title)
            else:
                # increment fft_list counter
                cnt += 1
                
            for i in xrange(len(loc)):
                try:
                    # get time & board & sensor
                    x = cols[i]._Time[win]
                    board = getattr(cols[i], 'Board%i' % (bo))
                    sensor = getattr(board, 'Sensor%i' % (se))
                except:
                    print '(spectral) -- Missing: L%i, Board %i, Sensor %i' % (i+1, bo, se)
                    continue
                if not sensor.is_valid:
                    if not include_invalide:
                        print '(spectral) -- Invalid: L%i, Board %i, Sensor %i' % (i+1, bo, se)
                        continue
                # calculate fft spectrum
                y = sensor()[win]
                y = sp.signal.filtfilt(b, a, y)
                if win_fcn is not None:
                    fft = np.abs(np.fft.fft(y*win_fcn))
                else:
                    fft = np.abs(np.fft.fft(y))
                frq = np.fft.fftfreq(len(x), 0.01)
                fft = fft[range(len(x)/2)]
                frq = frq[range(len(x)/2)]
                if not pool:
                    # plot fft data
                    ax = plt.subplot(111)
                    fft /= sum(fft)
                    line = plt.plot(frq, fft, color=rgb_tuples[i*45], \
                            linewidth=2, marker='s')
                    lines.append(line[0])
                else:
                    # add data to list
                    fft_list[i][cnt] += fft
    
            if not pool:
                # add legend
                if show_legend:
                    ax.legend(iter(lines), ['L%i'%(i) for i in loc], loc='center right')
                plt.xlim(0, 0.5)
                plt.ylim(0, 0.5)
                plt.xlabel('Frequency [Hz]')
                plt.ylabel('Normalized power [percent]')
                # create custom minor ticks
                locator = AutoMinorLocator()
                ax.xaxis.set_minor_locator(locator)
                ax.tick_params(axis='x',which='minor')
                ax.grid(which='both')
                plt.show()
                
    if pool:
        # create pooled figure
        fig = plt.figure()
        title = '%s L1-L6 %s %s, %i boards, %i sensors' % (cols[0].Gas, cols[0].SensorVoltage,
                                       cols[0].FanSpeed, len(brd), len(snsr))
        if show_title:
            fig.suptitle(title)
        sum_fft_list = np.zeros([len(loc),(win.stop-win.start)/2])
        std_fft_list = np.zeros([len(loc),(win.stop-win.start)/2])
        for i in xrange(len(loc)):
            ax = plt.subplot(111)
            for j in xrange(1,np.shape(fft_list)[1]):
                sum_fft_list[i] += fft_list[i][j]
            std_fft_list = np.std(fft_list[i],axis=0) / np.sum(sum_fft_list[i])
            sum_fft_list[i] /= np.sum(sum_fft_list[i])
            line = plt.plot(frq, sum_fft_list[i], color=rgb_tuples[i*45], \
                    linewidth=2, marker='s')
            plt.errorbar(frq, sum_fft_list[i], yerr=std_fft_list, color=rgb_tuples[i*45])
            lines.append(line[0])
        if show_legend:
            ax.legend(iter(lines), ['L%i'%(i) for i in loc], loc='center right')
        plt.xlim(0, 0.5)
        plt.ylim(0, 0.25)
        plt.xlabel('Frequency [Hz]')
        plt.ylabel('Normalized power [percent]')
        locator = AutoMinorLocator()
        ax.xaxis.set_minor_locator(locator)
        ax.tick_params(axis='x',which='minor')
        ax.grid(which='both')
        try:
            mng = plt.get_current_fig_manager()
            mng.window.showMaximized()
        except AttributeError:
            pass
        plt.show()    
        return fig, title, sum_fft_list, std_fft_list
    else:
        return handle_list, title_list
        
def psd(ds, **kwargs):
    """
    Plot selected comparative power spectral densities.
    Returns figure handle(s) and plot title(s); 
    If pool-flag is true, return compiled fft data aswell. 
    
    Keyword arguments:
    gas -- int or list of range(1,12), gas name identifier
    loc -- int or list of range(1,7), column location identifier
    voltage -- int of range(1,6) , sensor voltage identifier
    speed -- int of range(1,4) , fan speed identifier
    trial -- int of range(1,21), experiment repetitions
    board -- int or list of range(1,10), board identifier
    sensor -- int or list of range(1,9), sensor identifier
    pool -- bool, if true, compile all spectra into a single plot
    win -- slice, time series selection window
    win_fcn -- string, fourier transform window function to reduce leakage
    show_title -- bool, if true, display title on figure
    show_legend -- bool, if true, display legend
    include_invalide -- bool, include invalide sensors into analysis flag
    """
    assert isinstance(ds, DataSelector)
    
    # set default values
    default_gas = range(1,12)
    default_loc = range(1,7)
    default_voltage = 5
    default_speed = 1
    default_trial = range(1,21)
    default_board = range(1,10)
    default_sensor = range(1,9)
    default_pool = False
    default_win = slice(10000, 20000)

    # get arguments
    gas = kwargs.get('gas', default_gas)
    loc = kwargs.get('loc', default_loc)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)    
    brd = kwargs.get('board', default_board)
    snsr = kwargs.get('sensor', default_sensor)
    win_fcn = kwargs.get('win_fcn', 'blackman')
    pool = kwargs.get('pool', default_pool)
    show_legend = kwargs.get('show_legend', True)
    show_title = kwargs.get('show_title', True)
    include_invalide = kwargs.get('include_invalide', False)
    win = kwargs.get('win', default_win)
    
    # assert argument datatype 
    assert isinstance(gas, (int, list))
    assert isinstance(loc, (int, list))
    assert isinstance(voltage, (int, list)) 
    assert isinstance(speed, (int, list)) 
    assert isinstance(trial, (int, list)) 
    assert isinstance(brd, (int, list))
    assert isinstance(snsr, (int, list))
    assert isinstance(pool, bool)
    assert isinstance(show_title, bool)
    assert isinstance(show_legend, bool)
    assert isinstance(include_invalide, bool)
    assert isinstance(win_fcn, (str, type(None)))
    assert isinstance(win, slice)
    
    # cast int entries to list
    if isinstance(gas, int):
        gas = [gas]
    if isinstance(loc, int):
        loc = [loc]
    if isinstance(voltage, int):
        voltage = [voltage]
    if isinstance(speed, int):
        speed = [speed]
    if isinstance(trial,int):
        trial = [trial]
    if isinstance(brd, int):
        brd = [brd]
    if isinstance(snsr, int):
        snsr = [snsr]
    
    # assert argument value
    assert min(gas) > 0 and max(gas) <= 11
    assert min(loc) > 0 and max(loc) <= 6
    assert min(voltage) > 0 and max(voltage) <= 5
    assert min(speed) > 0 and max(speed) <= 3
    assert min(trial) > 0 and max(trial) <= 20
    assert min(brd) > 0 and max(brd) <= 9
    assert min(snsr) > 0 and max(snsr) <= 8
    assert win.start >= 0 and win.stop <= 26000
    
    
     # select columns
    cols = ds.select(gas=gas, loc=loc, speed=speed, voltage=voltage, trial=trial)
    
    rgb_tuples = plt.cm.spectral(np.arange(265)) # generate rgb color values
    lines = []
    b, a = sp.signal.butter(2, (float(0.01)/50, 1/float(50)), 'bandpass')
    
    if pool:
        # allocate fft data storage
        # TODO: Remove harcoded vector size
        psd_list = np.zeros([len(loc),len(brd)*len(snsr)+1,129])
        cnt = 0
    else:
        handle_list = []
        title_list = []
        
    for bo in brd:
        for se in snsr:
            
            if not pool:
                # generate individual figure
                fig = plt.figure()
                handle_list.append(fig)
                title = 'Spectral Density: %s L1-L6 %s %s %s Board %i, Sensor %i' % \
                (cols[0].Gas, cols[0].SensorVoltage, cols[0].FanSpeed, cols[0].TimeStamp, bo, se)
                if show_title:                
                    fig.suptitle(title)                
                title_list.append(title)
            else:
                # increment psd_list counter
                cnt += 1
                
            for i in xrange(len(loc)):
                try:
                    # get time & board & sensor
                    # x = cols[i]._Time[win]
                    board = getattr(cols[i], 'Board%i' % (bo))
                    sensor = getattr(board, 'Sensor%i' % (se))
                except:
                    print '(psd) -- Missing: L%i, Board %i, Sensor %i' % (i+1, bo, se)
                    continue
                if not sensor.is_valid:
                    if not include_invalide:
                        print '(psd) -- Invalid: L%i, Board %i, Sensor %i' % (i+1, bo, se)
                        continue
                # calculate psd using welch's method
                y = sensor()[win]
                y = sp.signal.filtfilt(b, a, y)
                frq, psd = sp.signal.welch(y, fs=100, window=win_fcn)
                if not pool:
                    # plot fft data
                    ax = plt.subplot(111)
                    line = plt.semilogy(frq, psd, color=rgb_tuples[i*45], \
                            linewidth=2)
                    lines.append(line[0])
                else:
                    # add data to list
                    psd_list[i][cnt] += psd
    
            if not pool:
                # maybe add legend
                if show_legend:
                    ax.legend(iter(lines), ['L%i'%(i) for i in loc], loc='center right')
                plt.xlabel('Frequency [Hz]')
                plt.ylabel('PSD [V**2/Hz]')
                plt.xlim(0, 2.0)
                plt.ylim(10e-5, 10e2)
                # create custom minor ticks
#                locator = AutoMinorLocator()
#                ax.xaxis.set_minor_locator(locator)
#                ax.tick_params(axis='x',which='minor')
#                ax.grid(which='both')
                plt.show()
                
    if pool:
        # create pooled figure
        fig = plt.figure()
        title = 'Spectral Density: %s L1-L6 %s %s, %i boards, %i sensors' % \
        (cols[0].Gas, cols[0].SensorVoltage, cols[0].FanSpeed, len(brd), len(snsr))
        if show_title:        
            fig.suptitle(title)
        sum_psd_list = np.zeros([len(loc),len(frq)])
        std_psd_list = np.zeros([len(loc),len(frq)])
        for i in xrange(len(loc)):
            ax = plt.subplot(111)
            for j in xrange(1,np.shape(psd_list)[1]):
                sum_psd_list[i] += psd_list[i][j]
            std_psd_list = np.std(psd_list[i],axis=0) / ((len(brd)*len(snsr))+1)
            sum_psd_list[i] /= ((len(brd)*len(snsr))+1)
            line = plt.semilogy(frq, sum_psd_list[i], color=rgb_tuples[i*45], \
                    linewidth=2)
            plt.errorbar(frq, sum_psd_list[i], yerr=std_psd_list, color=rgb_tuples[i*45])
            lines.append(line[0])
        if show_legend:
            ax.legend(iter(lines), ['L%i'%(i) for i in loc], loc='center right')
        plt.xlabel('Frequency [Hz]')
        plt.ylabel('Power spectral density [V**2/Hz]')
        plt.xlim(0, 2.0)
        plt.ylim(10e-5, 10e2)
#        locator = AutoMinorLocator()
#        ax.xaxis.set_minor_locator(locator)
#        ax.tick_params(axis='x',which='minor')
#        ax.grid(which='both')
        try:
            mng = plt.get_current_fig_manager()
            mng.window.showMaximized()
        except AttributeError:
            pass
        plt.show()    
        return fig, title, sum_psd_list
    else:
        return handle_list, title_list      
        
def power_distrib(ds, **kwargs):
    """
    Plot distribution of normalized spectral power over frequency range.
    Returns figure handle and compiled fft data. 
    
    Keyword arguments:
    gas -- int or list of range(1,12), gas name identifier
    loc -- int or list of range(1,7), column location identifier
    voltage -- int or list of range(1,6) , sensor voltage identifier
    speed -- int or list of range(1,4) , fan speed identifier
    trial -- int or list of range(1,21), experiment repetitions
    board -- int or list of range(1,10), board identifier
    sensor -- int or list of range(1,9), sensor identifier
    win_fcn -- string, fourier transform window function to reduce leakage
    win -- slice, time series selection window
    """
    
    # TODO: Implement errorbars
    
    assert isinstance(ds, DataSelector)
    
    # set default values
    default_gas = range(1,12)
    default_loc = range(1,7)
    default_voltage = 5
    default_speed = 1
    default_trial = range(1,21)
    default_board = range(1,10)
    default_sensor = range(1,9)
    default_win = slice(10000, 20000)

    # get arguments
    gas = kwargs.get('gas', default_gas)
    loc = kwargs.get('loc', default_loc)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)    
    brd = kwargs.get('board', default_board)
    snsr = kwargs.get('sensor', default_sensor)
    win_fcn = kwargs.get('win_fcn', None)
    win = kwargs.get('win', default_win)
    
    # assert argument datatype 
    assert isinstance(gas, (int, list))
    assert isinstance(loc, (int, list))
    assert isinstance(voltage, (int, list)) 
    assert isinstance(speed, (int, list)) 
    assert isinstance(trial, (int, list)) 
    assert isinstance(brd, (int, list))
    assert isinstance(snsr, (int, list))
    assert isinstance(win_fcn, (str, type(None)))
    assert isinstance(win, slice)
    
    # cast int entries to list
    if isinstance(gas, int):
        gas = [gas]
    if isinstance(loc, int):
        loc = [loc]
    if isinstance(voltage, int):
        voltage = [voltage]
    if isinstance(speed, int):
        speed = [speed]
    if isinstance(trial,int):
        trial = [trial]
    if isinstance(brd, int):
        brd = [brd]
    if isinstance(snsr, int):
        snsr = [snsr]
    
    # assert argument value
    assert min(gas) > 0 and max(gas) <= 11
    assert min(loc) > 0 and max(loc) <= 6
    assert min(voltage) > 0 and max(voltage) <= 5
    assert min(speed) > 0 and max(speed) <= 3
    assert min(trial) > 0 and max(trial) <= 20
    assert min(brd) > 0 and max(brd) <= 9
    assert min(snsr) > 0 and max(snsr) <= 8
    assert win.start >= 0 and win.stop <= 26000
    
    # try to construct window function
    if win_fcn is not None:
        if win_fcn in ('Hamming', 'hamming'):
            win_fcn = np.hamming(win.stop-win.start)
        elif win_fcn in ('Blackman', 'blackman'):
            win_fcn = np.blackman(win.stop-win.start)
        elif win_fcn in ('Hanning', 'hanning'):
            win_fcn = np.hanning(win.stop-win.start)
        elif win_fcn in ('Bartlett','bartlett'):
            win_fcn = np.bartlett(win.stop-win.start)
        else:
            win_fcn = None
    
    b, a = sp.signal.butter(2, (float(0.01)/50, 1/float(50)), 'bandpass')
    n = len(gas)*len(loc)*len(speed)*len(voltage)*len(trial)*len(brd)*len(snsr)
    fft_list = np.zeros([n,(win.stop-win.start)/2])
    std_list = np.zeros((win.stop-win.start)/2)
    cnt = 0
    
    # iterate over all parameters
    for g in gas:
        for l in loc:
            for s in speed:
                for v in voltage:
                    for t in trial:
                        try:
                            # try to get column
                            cols = ds.select(gas = g, loc = l, voltage = v, \
                            speed = s, trial = t)
                            x = cols[0]._Time[win]
                        except:
                            print '-- Missing: Gas %i, L%i, Trial %i' % (g, l, t)
                            continue
                        for bo in brd:
                            try:
                                # get board
                                board = getattr(cols[0], 'Board%i' % (bo))
                            except:
                                print '-- Missing: Gas %i, L%i, %s, %s, Trial %i, Board %i' % \
                                (g, l, ds.AltFanSpeeds[s], ds.SensorVoltages[v], t, bo)
                                continue
                            for se in snsr:
                                # get sensor
                                sensor = getattr(board, 'Sensor%i' % (se))
                                if sensor.is_valid:
                                    # fourier transform 
                                    y = sensor()[win]
                                    y = sp.signal.filtfilt(b, a, y)
                                    if win_fcn is not None:
                                        fft = np.abs(np.fft.fft(y*win_fcn))
                                    else:
                                        fft = np.abs(np.fft.fft(y))
                                    fft = fft[range(len(x)/2)]
                                    # pool data
                                    fft_list[cnt] = fft
                                    cnt += 1
                                    

    fft_list = fft_list[0:cnt-1]
    
    # print 'fft_list: (%i,%i)' % (np.shape(fft_list)[0], np.shape(fft_list)[1])
    
    std_list = np.std(fft_list, axis=0)
    fft_list = np.sum(fft_list, axis=0)
    
    # print 'Max Std. pre: %f' % np.max(std_list)
    # print 'Max Pwr. pre: %f' % np.max(fft_list)
    
    # normalize pooled data
    std_list /= np.sum(fft_list)
    fft_list /= np.sum(fft_list)
    
    # print 'Max Std. post: %f' % np.max(std_list)
    # print 'Max Pwr. post: %f' % np.max(fft_list)
    
    # calculate frequencies
    frq = np.fft.fftfreq(len(x), 0.01)
    frq = frq[range(len(x)/2)]
    
    fig = plt.figure()
    ax = fig.add_subplot(111)
    plt.plot(frq, fft_list, 'k')
    
    # plt.errorbar(frq, fft_list, yerr=std_list, color='k')
    
    plt.fill_between(frq, fft_list, color = 'gray')
    
    # TODO: Implement xlim & ylim as input variables.
    plt.xlim(0.0, 0.5)
    plt.ylim(0.0, 0.25)
    # create custom minor ticks
    locator = AutoMinorLocator()
    ax.xaxis.set_minor_locator(locator)
    ax.tick_params(axis='x',which='minor')
    ax.grid(which='both')
    
    plt.xlabel('Frequency [Hz]')
    plt.ylabel('Power ratio')
    # calculate amount of power in dsiplayed range
    pwr = np.round(sum(fft_list[range(0,50)])*100, decimals=2)
    
    # plt.text(0.15, 0.2, '%s %% of total Power' % (pwr), fontsize=12)
    
    print 'The displayed range contains %s %% of the total power' % (pwr)
    print '%i Columns' % cnt

    try:
        mng = plt.get_current_fig_manager()
        mng.window.showMaximized()
    except AttributeError:
        pass
    plt.show()
    return fig, fft_list                          

def peak_phase(ds, **kwargs):
    """
    Plot distance-based differences in onset and recovery timing.
    Highlight area around the selected window.
    Returns figure handle and title.
    
    Keyword arguments:
    gas -- int of range(1,12), gas name identifier
    loc -- int of range(1,7), column location identifier
    voltage -- int of range(1,6) , sensor voltage identifier
    speed -- int of range(1,4) , fan speed identifier
    trial -- int of range(1,21), experiment repetitions
    board -- int of range(1,10), board identifier
    sensor -- int of range(1,9), sensor identifier
    win -- slice, time series selection window
    show_legend -- bool, if true, display legend
    """
    assert isinstance(ds, DataSelector)
    
    # set default values
    default_gas = 1
    default_voltage = 5
    default_speed = 1
    default_trial = 1
    default_board = 5
    default_sensor = 5
    default_win = slice(10000, 20000)
    
    # get arguments
    gas = kwargs.get('gas', default_gas)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)
    brd = kwargs.get('board', default_board)
    snsr = kwargs.get('sensor', default_sensor)
    win  = kwargs.get('win', default_win)
    show_legend = kwargs.get('show_legend', True)
    
    # assert arguments type & value
    assert isinstance(gas, int) and gas in range(1,12)
    assert isinstance(voltage, int) and voltage in range(1,6)
    assert isinstance(speed, int) and speed in range(1,4)
    assert isinstance(trial, int) and trial in range(1,21)
    assert isinstance(brd, int) and brd in range(1,10)
    assert isinstance(snsr, int) and snsr in range(1,9)
    assert isinstance(win, slice)
    assert isinstance(show_legend, bool)
    
    # select column
    cols = ds.select(gas = gas, speed = speed, voltage = voltage, trial = trial)
    
    # create title
    title = 'Peak-phase: %s L1-L6 %s %s %s' % (cols[0].Gas, cols[0].SensorVoltage,
                               cols[0].FanSpeed, cols[0].TimeStamp)
                               
    # create figure
    fig = plt.figure()
    ax = plt.subplot(111)
    
    # plot timeseries
    lines = []
    for i in range(len(cols)):
        try:
            board = getattr(cols[i], 'Board%i' % (brd))
            sensor = getattr(board, 'Sensor%i' % (snsr))
        except:
            print '-- Missing: Gas %i, %s, %s, Trial %i, Board %i' % \
                                (gas, cols[0].FanSpeed, cols[0].SensorVoltage, \
                                trial, brd)
        l = plt.plot( sensor.get_filtered, linewidth=2 )
        lines.append(l[0])
    
    # create legend
    if show_legend:
        fig.legend(iter(lines), ('L1', 'L2', 'L3', 'L4', 'L5', 'L6'), \
            loc='center right', bbox_to_anchor=(0.975, 0.5))
    
    # color area around the window of interest
    plt.axvspan(0, win.start, facecolor='gray', alpha=0.5)
    plt.axvspan(win.stop, 26000, facecolor='gray', alpha=0.5)

    # create custom ticks & labels    
    locs, labels = plt.xticks()
    labels = np.linspace(0,300,7)
    plt.xticks(locs, labels)
    plt.xlim([0, 26000])
    plt.xlabel('Time  [sec]')
    plt.ylabel('Resistance [Ohms]')
    
    plt.grid(True)
    
    try:
        mng = plt.get_current_fig_manager()
        mng.window.showMaximized()
    except AttributeError:
        pass
    plt.show()
    
    return fig, title
    
def sample_rate(ds, **kwargs):
    """
    Plot sample rate interval size histogram.  
    Returns figure handle, title and histogram.
    
    Keyword arguments:
    gas -- int of range(1,12), gas name identifier
    loc -- int of range(1,7), column location identifier
    voltage -- int of range(1,6) , sensor voltage identifier
    speed -- int of range(1,4) , fan speed identifier
    trial -- int of range(1,21), experiment repetitions
    xlim -- [int int], x-axis limit
    show_title -- bool, if true, display title
    """
    
    assert isinstance(ds, DataSelector)
    
    # set default values
    default_gas = 1
    default_voltage = 5
    default_speed = 1
    default_trial = 1
    default_xlim = [0, 35]
    
    # get arguments
    gas = kwargs.get('gas', default_gas)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)
    xlim = kwargs.get('xlim', default_xlim)
    show_title = kwargs.get('show_title', False)
    
    # assert arguments type & value
    assert isinstance(gas, int) and gas in range(1,12)
    assert isinstance(voltage, int) and voltage in range(1,6)
    assert isinstance(speed, int) and speed in range(1,4)
    assert isinstance(trial, int) and trial in range(1,21)
    assert isinstance(xlim, list) and len(xlim) == 2
    
    # select column
    cols = ds.select(gas = gas, speed = speed, voltage = voltage, trial = trial)
    
    # calculate sampling interval size
    interval = cols[0].get_time()[1:]-cols[0].get_time()[:-1]
    
    # create title
    title = 'Sampling rate inverval size: %s %s %s %s %s' % (cols[0].Gas, cols[0].Name,
                 cols[0].SensorVoltage, cols[0].FanSpeed, cols[0].TimeStamp)
    
    fig = plt.figure()    

    if show_title:
        fig.suptitle(title, fontsize=16)

    plt.hist(interval, bins=500, color='green')
    plt.xlim(xlim)

    print 'Total number of samples: %i' % (len(cols[0]._Time))
    print 'Actual sample rate: %f Hz' % float(len(cols[0]._Time)/260)
    
    return fig, title, interval
    
    
    
    
