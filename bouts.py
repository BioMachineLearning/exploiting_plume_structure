# -*- coding: utf-8 -*-
"""
Enhancing the slow enose signals using some neat data processing.


Created on Mon Apr 27 17:57:27 2015

@author: micha
"""

import numpy as np
import pandas as pd

class EWMABoutCounter(object):
    """
    Encapsulates data analysis for the Exponential Moving Average 
    Bout Counting.
    
    Typical workflow:
    0. create object:
    >>> ebc = EWMABoutCounter(signal=sig, halflife=40)
    1. compute the EWMA of the smoothed derivative of the signal
    >>> dtd = ebc.smooth_time_deriv_ewma()
    2. compute and count bouts
    >>> ebc.compute_bout_count(ampthresh=0.01, durthresh=50)
    
    The bout intervals in the signal are then in ebc.filtered_posneg
    """
    def __init__(self, signal, halflife, smooth_std):
        """
        Parameters:
        signal - the signal time series
        halflife - the halflife of the exponential kernel of EWMA in samples.
        smooth_std - standard deviation of smoothing kernel (gauss)
        """
        self.set_signal(signal)
        self.halflife = halflife
        self.smooth_std = smooth_std
        
    def set_signal(self, s):
        """
        Set the signal of this object.
        Parameters:
        s - the signal time series
        """
        self.signal = s
        self._signal_changed()
        
    def get_bouts_of_positive_derivative(self):
        """
        returns a 2xN array of indices. The first row corresponds to 
        indices where the derivative of the EWMA-filtered time-derivative
        of the smoothed signal becomes positive (the beginning of a bout).
        The second row corresponds to indices where it becomes negative again
        (the end of a bout).
        """
        if self.posneg is None:
            self._compute_bouts()
        return self.posneg
    
    def smooth_time_deriv_ewma(self):
        """
        Computes the EWMA-filtered time-derivative of the smoothed signal.
        """
        if self.sig_diff_ewma is None:
            self._compute_sig_diff_ewma()
        return self.sig_diff_ewma
    
    def compute_filtered_bout_count(self, ampthresh=0., durthresh=0.):
        """
        Compute the number of bouts, their amplitudes, and their durations.
        Discard bouts that are smaller of shorted than the specified thresholds.
        Parameters:
        ampthresh - amplitude threshold
        durthresh - duration threshold
        """
        if self.sig_diff_ewma is None:
            self._compute_sig_diff_ewma()
        posneg = self.get_bouts_of_positive_derivative()
        # filter low-amplitude bouts
        self._compute_amps()
        self.ampthresh = ampthresh
        self.superthresh_amp = np.nonzero(self.amps > ampthresh)[0]
        if len(self.superthresh_amp) < 1:
            raise(Warning(
            "No bouts exceeding amplitude threshold {:.3g}. ".format(ampthresh) + 
            "Largest bout is {:.3g}".format(max(self.amps))))
        self.filtered_posneg = posneg[:, self.superthresh_amp]
        # filter short bouts
        self.durthresh = durthresh
        pos_bout_durations = np.diff(self.filtered_posneg, axis=0).squeeze()
        if len(pos_bout_durations.shape) < 1:
            pos_bout_durations = np.array([pos_bout_durations])
        superthresh_dur = np.where(pos_bout_durations > durthresh)[0]
        if len(superthresh_dur) < 1:
            raise(Warning(
            "No bouts exceeding duration threshold {:.3g}. ".format(durthresh) + 
            "Longest bout is {:.3g}".format(max(pos_bout_durations))))
        self.filtered_durations = pos_bout_durations[superthresh_dur]
        self.filtered_posneg = self.filtered_posneg[:,superthresh_dur]
    
    def number_of_bouts(self):
        """
        convenience function to access the number of (filtered) bouts detected.
        """
        if not (self.filtered_posneg is None):
            retval = self.filtered_posneg.shape[1]
        else:
            retval = 0
        return retval
        
    def median_bout_length(self):
        """
        Convenience function to access the median duration of filtered bouts.
        """
        return np.median(self.filtered_durations)
    
    def median_bout_amplitude(self):
        """
        Convenience function to access the median amplitude of filtered bouts.
        """
        return np.median(self.superthresh_amp)
    
    def amps_in_timespan(self, timespan):
        """
        Return the amplitudes encountered in the given timespan.
        
        Parameters:
        timespan - 2-tuple of start and end indices to consider
        """
        self._compute_amps()
        larger_than_start = self.posneg[0] > timespan[0]
        smaller_than_end = self.posneg[1] < timespan[1]
        in_timespan = larger_than_start & smaller_than_end
        idx_in_timespan = np.nonzero(in_timespan)[0]
        if len(idx_in_timespan) < 1:
            retval = np.array([])
        else:
            first_idx = idx_in_timespan[0]
            last_idx = idx_in_timespan[-1]
            retval = self.amps[first_idx:last_idx]
        return retval
        
    def _compute_amps(self):
        """
        Internal method to compute bout amplitudes.
        """
        if self.posneg is None:
            self._compute_bouts()
        s = self.sig_diff_ewma
        self.amps = np.array([s[p[1]] - s[p[0]] for p in self.posneg.T])    
    
    def _compute_sig_diff_ewma(self):
        """
        Internal method to compute the EWMA-filtered time-derivative of the smoothed signal.
        """
        sig_smooth = pd.rolling_window(self.signal, 300, 'gaussian', std=self.smooth_std) #window is 300 ms, gaussian std is 30 ms (5 sigma)
        sig_diff = np.diff(sig_smooth)
        sig_diff_ewma = pd.ewma(sig_diff, halflife=self.halflife, adjust=False, ignore_na=True)
        non_nan_cols = np.nonzero(~np.isnan(sig_diff_ewma))[0]
        self.sig_diff_ewma = sig_diff_ewma[non_nan_cols]
        self.non_nan_cols = non_nan_cols
        

    def _signal_changed(self):
        """
        reset this object to the blank state.
        """
        self.posneg = None
        self.sig_diff_ewma = None
        self.halflife = None
        self.amps = None
        self.ampthresh = 0.
        self.durthresh = 0.
        self.filtered_posneg = None
        self.superthresh_amp = None
        self.superthresh_dur = None
    
    def _compute_bouts(self):
        """
        Internal method to compute the "bouts" in the signal (i.e.,
        the zero-transitions of the derivative of the EWMA-filtered time-derivative of the smoothed signal.
        """
        if self.sig_diff_ewma is None:
            self._compute_sig_diff_ewma()
        sd = np.diff(self.sig_diff_ewma) # derivative
        sd_pos = sd >=0. # positive part of the derivative
        signchange = np.diff(np.array(sd_pos, dtype=int)) #Change neg->pos=1, pos->neg=-1.
        pos_changes = np.nonzero(signchange > 0)[0]
        neg_changes = np.nonzero(signchange < 0)[0]
        # have to ensure that first change is positive, and every pos. change is complemented by a neg. change
        if pos_changes[0] > neg_changes[0]: #first change is negative
            #discard first negative change
            neg_changes = neg_changes[1:]
        if len(pos_changes) > len(neg_changes): # lengths must be equal
            difference = len(pos_changes) - len(neg_changes)
            pos_changes = pos_changes[:-difference]
        posneg = np.zeros((2,len(pos_changes)))
        posneg[0,:] = pos_changes
        posneg[1,:] = neg_changes
        self.posneg = posneg

#############################
### Various helper functions 

from sklearn import linear_model
from sklearn import cross_validation
import pylab
import matplotlib as mpl

def estimate_ampthresh(ebcs, data, use_data_baseline=False, print_summary=True):
    """
    estimate the amplitude threshold to exclude noise bouts from 
    3 standard deviations of the mean amplitudes encountered during 
    the baseline in the data.
    
    Parameters:
    ebcs - N x M array of EWMABoutCounter objects from N distances and M trials
    data - N x M list-like of SensorColumn objects
    use_baseline_from_data - determine baseline from MFC onset (default:use fist 10s)
    print_summary - print the summary statistics of bouts.
    
    Returns:
    ampthresh - the mean amplitude during baseline + 3 standard deviations   
    """
    amps = np.zeros_like(ebcs)
    for i in xrange(len(ebcs)):
        for j in xrange(len(ebcs[i])):
            if use_data_baseline:
                baseline = data[i][j].get_baseline()
            else:
                baseline = (0,1000)
            amps[i,j] = ebcs[i][j].amps_in_timespan(baseline)
    amps_conc = np.concatenate(tuple([af for af in amps.flat]))
    ampthresh = np.mean(amps_conc) + 3*np.std(amps_conc)
    if print_summary:
        print("amp stats: mean: {:.3g} std: {:.3g} median: {:.3g} min: {:.3g} max: {:.3g}".format(
        np.mean(amps_conc), np.std(amps_conc), np.median(amps_conc), np.min(amps_conc), np.max(amps_conc)))
    return ampthresh

def make_boutcounters(data, 
                      sensorname="Sensor3", 
                      boardname="Board5", 
                      halflife=40, 
                      smooth_std=30., 
                      ampthresh=None,
                      use_data_baseline=False,
                      durthresh=0., 
                      verbose=True):
    """
    Generate the EWMABoutCounter objects for the data traces.
    
    Parameters:
    data - N x M list of SensorColumn objects for N distances and M trials
    sensorname - string identifying the sensor to analyse
    boardname - string identifying the sensor to analyse (defines vertical position, 5=centre)
    halflife - halflife of the exponential kernel for EWMA filtering
    smooth_std - standard deviation of the gaussian kernel for smoothing the raw traces
    ampthresh - minimal amplitude for bouts for being considered (if None, estimate as mean+3std baseline)
    use_data_baseline - infer baseline timespan from MFC data (default: use first 10s)
    durthresh - minimal duration of bouts for being considered (deprecated - presumably not useful)
    
    Returns:
    ebcs - M x N array with EWMABoutCounter objects for M distances and N trials
    """
    num_dist = len(data)
    num_trials = len(data[0])
    for d in data:
        assert len(d) == num_trials
    ebcs = np.zeros((num_dist,num_trials), dtype=object)
    for distance in xrange(num_dist):
        for trial in xrange(num_trials):
            sensor = eval("data[{}][{}].{}.{}".format(distance,trial,boardname,sensorname)) 
        #    time = sensor.get_time()/1000. # convert to s
            signal = sensor.get_data()
            ebc = EWMABoutCounter(signal, halflife=halflife, smooth_std=smooth_std) 
            ebcs[distance,trial] = ebc
    if ampthresh is None:
        at = estimate_ampthresh(ebcs, 
                                data, 
                                use_data_baseline=use_data_baseline, 
                                print_summary=verbose)
        if verbose:
            print("Using estimated ampthresh = {:.3g}".format(at))
    else:
        at = ampthresh
    for distance in xrange(num_dist):
        for trial in xrange(num_trials):
            try:
                ebcs[distance][trial].compute_filtered_bout_count(ampthresh=at)
            except Warning, m:
                if verbose:
                    print("Warning encountered at distance {} trial {}:".format(distance, trial))
                    print m
    return ebcs

def calc_boutcounts(ebcs):
    """
    Calculate the number of bouts in the signals.
    
    Parameters:
    ebcs - EWMABoutCounter objects , M x N list-like, M number of distances, N number of trials
    
    Returns:
    boutcounts - array same shape as ebcs containing the number of bouts in each trial
    """
    boutcounts = np.zeros_like(ebcs)
    for trial in xrange(ebcs.shape[1]):
        boutcounts[:,trial] = [ebcs[distance, trial].number_of_bouts() for distance in xrange(ebcs.shape[0])]
    return boutcounts

def regress_mean(boutcounts, pdists=[0.25, 0.5, 0.98, 1.18, 1.40, 1.45], print_summary=True):
    """
    Fit a linear model to mean bout count.
    
    Parameters:
    boutcounts - N x M array of bout counts, with N the number of distances and M the number of trials
    pdists - distances to use in the regression
    print_summary - print a summary of the model performance
    
    Returns: dictionary with keys
    mf - fitted model
    r2 - R2 score on the fitted model
    rmse - RMSE of the fitted model
    """ 
    dists = np.array(pdists)
    X = np.matrix(np.mean(np.array(boutcounts), axis=1)).T
    m = linear_model.LinearRegression()
    mf = m.fit(X, dists)
    r2 = mf.score(X, dists)
    rmse = np.sqrt(np.mean((mf.predict(X) - dists)**2))
    if print_summary:
        print("RMSE: {:.3f} m, R2={:.3f}".format(rmse, r2))
    retdict = {'mf':mf,
               'r2':r2,
               'rmse':rmse}
    return retdict

def regress_crossval_score(boutcounts, 
                           pdists=[0.25, 0.5, 0.98, 1.18, 1.40, 1.45], 
                           num_cv=5,
                           print_summary=True):
    """
    Cross-validate linear models of boutcount vs. distance.
    
    Parameters:
    boutcounts - N x M array of bout counts, with N the number of distances and M the number of trials
    pdists - distances to use in the regression
    num_cv - number of folds for cross-validation
    print_summary - print a summary of the model performance
    
    Returns: dictionary with keys
    r2 - N x 1 array of cross-validated R2 scores, N = number of folds
    rmse - N x 1 array of cross-validated RMSE, N = number of folds
    
    """
    num_dist = boutcounts.shape[0]
    num_trials = boutcounts.shape[1]
    X = np.zeros(num_dist * num_trials)
    Y = np.zeros(num_dist * num_trials)
    for d in xrange(num_dist):
        for t in xrange(num_trials):
            X[t*num_dist+d] = boutcounts[d,t]
            Y[t*num_dist+d] = pdists[d]
    X = np.matrix(X).T
    m = linear_model.LinearRegression()
    R2_CV = cross_validation.cross_val_score(m, X, Y, cv=num_cv, scoring='r2')
    RMSE_CV = np.sqrt(-cross_validation.cross_val_score(m, X, Y, cv=num_cv, scoring='mean_squared_error'))
    if print_summary:
        print("CV: R2={:.3f} (± {:.3f})".format(np.mean(R2_CV), np.std(R2_CV) * 2))
        print("CV: RMSE: {:.3f} m (± {:.3f})".format(np.mean(RMSE_CV), np.std(RMSE_CV) * 2))
    retdict = {'r2':R2_CV, 'RMSE': RMSE_CV}
    return retdict

def pick_best_sensor(data, 
                     pdists=np.array([0.25, 0.5, 0.98, 1.18, 1.40, 1.45]), 
                     use_data_baseline=True,
                     print_summary=True):
    """
    Identify which sensor gives the lowest RMSE in CV.
    
    Parameters:
    data - M x N list-like containing SensorColumn objects, M distances and N trials
    pdists - the distance values in cm
    use_data_baseline - infer baseline timespan from MFC data (default: use 40 s)
    print_summary - print a summary of the sensor rank statistics
    
    returns: tuple sensorname, ebcs
    sensorname: sensor name string
    ebcs: EWMABoutCounter objects for this sensor
    """
    sensornames = ["Sensor{}".format(i) for i in xrange(1,9)]
    rmses = np.zeros(len(sensornames))
    ebcs_collections = []
    for i,sens in enumerate(sensornames):
        ebcs = make_boutcounters(data, 
                                 sensorname=sens, 
                                 boardname="Board5", 
                                 use_data_baseline=use_data_baseline,
                                 verbose=False)
        boutcounts = calc_boutcounts(ebcs)
        CV_dict = regress_crossval_score(boutcounts, pdists, print_summary=False)
        rmses[i] = np.mean(CV_dict["RMSE"])
        ebcs_collections.append(ebcs)
    rank = np.argsort(rmses)
    if print_summary:
        for r in rank:
            print("{}:\t{:.3f}".format(sensornames[r], rmses[r]))
    return sensornames[rank[0]], ebcs_collections[rank[0]]

def plot_bouts(ebcs, trial=0):
    """
    Helper function to visualise detected bouts on the EWMA-filtered signal.
    
    Parameters:
    ebcs - M x N array of EWMABoutCounter objects, M distances, N trials
    trial - the index of the trial to plot.
    """
    f = pylab.figure(figsize=(4,4))
    gs = mpl.gridspec.GridSpec(6,1)
    for i,d in enumerate(np.array([0.25, 0.5, 0.98, 1.18, 1.40])):
        ebc = ebcs[i][4]
        ax = f.add_subplot(gs[i]) 
        s = ebc.smooth_time_deriv_ewma()
        p = ebc.filtered_posneg
        xaxis = [x/100. for x in xrange(len(s))]
        ax.plot(xaxis, s, color='k')
        if not (p is None):
            for j in p.T:
                ax.plot(np.arange(j[0], j[1])/100., s[j[0]:j[1]], color='red')
        ax.yaxis.set_ticks_position('left')
        if i == 4:
            ax.xaxis.set_ticks_position('bottom')
            ax.set_xlabel('time [s]')
        else:
            ax.set_xticks([])
            ax.xaxis.set_ticks_position('none')
        ax.set_frame_on(False)
