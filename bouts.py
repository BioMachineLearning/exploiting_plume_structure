# -*- coding: utf-8 -*-
"""
Enhancing the slow enose signals using some neat data processing.


Created on Mon Apr 27 17:57:27 2015

@author: micha
"""

import numpy as np
import pandas as pd

class EWMABoutCounter(object):
    """
    Encapsulates data analysis for the Exponential Moving Average 
    Bout Counting.
    
    Typical workflow:
    0. create object:
    >>> ebc = EWMABoutCounter(signal=sig, halflife=40)
    1. compute the EWMA of the smoothed derivative of the signal
    >>> dtd = ebc.smooth_time_deriv_ewma()
    2. compute and count bouts
    >>> ebc.compute_bout_count(ampthresh=0.01, durthresh=50)
    
    The bout intervals in the signal are then in ebc.filtered_posneg
    """
    def __init__(self, signal, halflife, smooth_std):
        """
        Parameters:
        signal - the signal time series
        halflife - the halflife of the exponential kernel of EWMA in samples.
        smooth_std - standard deviation of smoothing kernel (gauss)
        """
        self.set_signal(signal)
        self.halflife = halflife
        self.smooth_std = smooth_std
        
    def set_signal(self, s):
        """
        Set the signal of this object.
        Parameters:
        s - the signal time series
        """
        self.signal = s
        self._signal_changed()
        
    def get_bouts_of_positive_derivative(self):
        """
        returns a 2xN array of indices. The first row corresponds to 
        indices where the derivative of the EWMA-filtered time-derivative
        of the smoothed signal becomes positive (the beginning of a bout).
        The second row corresponds to indices where it becomes negative again
        (the end of a bout).
        """
        if self.posneg is None:
            self._compute_bouts()
        return self.posneg
    
    def smooth_time_deriv_ewma(self):
        """
        Computes the EWMA-filtered time-derivative of the smoothed signal.
        """
        if self.sig_diff_ewma is None:
            self._compute_sig_diff_ewma()
        return self.sig_diff_ewma
    
    def compute_filtered_bout_count(self, ampthresh=0., durthresh=0.):
        """
        Compute the number of bouts, their amplitudes, and their durations.
        Discard bouts that are smaller of shorted than the specified thresholds.
        Parameters:
        ampthresh - amplitude threshold
        durthresh - duration threshold
        """
        if self.sig_diff_ewma is None:
            self._compute_sig_diff_ewma()
        posneg = self.get_bouts_of_positive_derivative()
        # filter low-amplitude bouts
        self._compute_amps()
        self.ampthresh = ampthresh
        self.superthresh_amp = np.nonzero(self.amps > ampthresh)[0]
        self.filtered_posneg = posneg[:, self.superthresh_amp]
        # filter short bouts
        self.durthresh = durthresh
        pos_bout_durations = np.diff(self.filtered_posneg, axis=0).squeeze()
        superthresh_dur = np.where(pos_bout_durations > durthresh)[0]
        self.filtered_durations = pos_bout_durations[superthresh_dur]
        self.filtered_posneg = self.filtered_posneg[:,superthresh_dur]
    
    def _compute_amps(self):
        """
        Internal method to compute bout amplitudes.
        """
        if self.posneg is None:
            self._compute_bouts()
        s = self.sig_diff_ewma
        self.amps = np.array([s[p[1]] - s[p[0]] for p in self.posneg.T])    
    
    def _compute_sig_diff_ewma(self):
        """
        Internal method to compute the EWMA-filtered time-derivative of the smoothed signal.
        """
        sig_smooth = pd.rolling_window(self.signal, 300, 'gaussian', std=self.smooth_std) #window is 300 ms, gaussian std is 30 ms (5 sigma)
        sig_diff = np.diff(sig_smooth)
        sig_diff_ewma = pd.ewma(sig_diff, halflife=self.halflife, adjust=False, ignore_na=True)
        non_nan_cols = np.nonzero(~np.isnan(sig_diff_ewma))[0]
        self.sig_diff_ewma = sig_diff_ewma[non_nan_cols]
        self.non_nan_cols = non_nan_cols
        

    def _signal_changed(self):
        """
        reset this object to the blank state.
        """
        self.posneg = None
        self.sig_diff_ewma = None
        self.halflife = None
        self.amps = None
        self.ampthresh = 0.
        self.durthresh = 0.
        self.filtered_posneg = None
        self.superthresh_amp = None
        self.superthresh_dur = None
    
    def _compute_bouts(self):
        """
        Internal method to compute the "bouts" in the signal (i.e.,
        the zero-transitions of the derivative of the EWMA-filtered time-derivative of the smoothed signal.
        """
        if self.sig_diff_ewma is None:
            self._compute_sig_diff_ewma()
        sd = np.diff(self.sig_diff_ewma) # derivative
        sd_pos = sd >=0. # positive part of the derivative
        signchange = np.diff(np.array(sd_pos, dtype=int)) #Change neg->pos=1, pos->neg=-1.
        pos_changes = np.nonzero(signchange > 0)[0]
        neg_changes = np.nonzero(signchange < 0)[0]
        # have to ensure that first change is positive, and every pos. change is complemented by a neg. change
        if pos_changes[0] > neg_changes[0]: #first change is negative
            #discard first negative change
            neg_changes = neg_changes[1:]
        if len(pos_changes) > len(neg_changes): # lengths must be equal
            difference = len(pos_changes) - len(neg_changes)
            pos_changes = pos_changes[:-difference]
        posneg = np.zeros((2,len(pos_changes)))
        posneg[0,:] = pos_changes
        posneg[1,:] = neg_changes
        self.posneg = posneg
