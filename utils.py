import os
import time
import numpy as np
from matplotlib import pyplot as plt
from plumy.SensorColumn import SensorColumn


def specstats(ds, **kwargs):
    """
    (deprecated) Load and encapsule single sensor data and statistic into nested hirarchy.
    """
    import scipy

    default_gas = [1,2,3,4,6,7,8,11]
    default_trial = [1,2,3,4,5]
    default_voltage = [5]
    default_speed = [1]
    default_board = [5]
    default_sensor = [3,4,5,6,7]

    gas = list(kwargs.get('gas', default_gas))
    trial = list(kwargs.get('trial', default_trial))
    voltage = list(kwargs.get('voltage', default_voltage))
    speed = list(kwargs.get('speed', default_speed))
    board = list(kwargs.get('board', default_board))
    sensor = list(kwargs.get('sensor', default_sensor))
    win = kwargs.get('win', slice(10000, 20000))
    max_freq = kwargs.get('max_freq', 0.5)
    norm = kwargs.get('norm', None)
    filt = kwargs.get('filt', True)
    pool = kwargs.get('pool', False)

    assert isinstance(ds, DataSelector)
    if norm is not None:
        assert isinstance(norm, str)
    assert isinstance(win, slice)
    assert 1000 <= win.start <= 26000
    assert 1000 <= win.stop <= 26000
    assert win.start < win.stop
    assert isinstance(max_freq, float)
    assert max_freq <= 50

    if not pool and norm in ('colsum','colmax'):
        print 'norm="%s" only allowed with pool=True' % norm
        return

    num_bands = len(np.arange(0, max_freq, 0.01))
    hist = np.zeros([6, len(trial), len(gas), len(voltage), len(speed),
                     len(board), len(sensor), num_bands])
    std = np.zeros([6, len(trial), len(gas), len(voltage), len(speed),
                    len(board), len(sensor)])
    mean = np.zeros([6, len(trial), len(gas), len(voltage), len(speed),
                     len(board), len(sensor)])
    var = np.zeros([6, len(trial), len(gas), len(voltage), len(speed),
                    len(board), len(sensor)])
    filt_b, filt_a = scipy.signal.butter(2, (float(0.01)/50, 1/float(50)),
                                         'bandpass')

    for loc in xrange(6):  # L1-L6
        for t, t_data in enumerate(trial):
            for g, g_data in enumerate(gas):
                for v, v_data in enumerate(voltage):
                    for sp, sp_data in enumerate(speed):
                        col = ds.select(gas=g_data, voltage=v_data,
                                        speed=sp_data, loc=loc+1, trial=t_data)
                        for b, b_data in enumerate(board):
                            try:
                                bo = getattr(col[0], 'Board%i' % b_data)
                            except:
                                print 'Missing Data @ Gas:%i,Loc:%i,Trial:%iSpeed:%iVoltage:%i' % \
                                    (g_data, loc+1, t_data, sp_data, v_data)
                                continue
                            for s, s_data in enumerate(sensor):
                                sens = getattr(bo, 'Sensor%i' % s_data)
                                # if sens.is_valid:
                                x = sens._Time[win]
                                y = sens()[win]
                                if filt:
                                    y = scipy.signal.filtfilt(filt_b,
                                                              filt_a, y)
                                fft = np.abs(np.fft.fft(y))
                                frq = np.fft.fftfreq(len(x), 0.01)
                                fft = fft[range(len(x)/2)]
                                frq = frq[range(len(x)/2)]
                                spln = scipy.interpolate.UnivariateSpline(frq, fft, s=0)
                                integral = np.array([spln.integral(i, i+1) for i in frq[range(num_bands)]])
                                std[loc][t][g][v][sp][b][s] = np.std(integral)
                                mean[loc][t][g][v][sp][b][s] = np.mean(integral)
                                var[loc][t][g][v][sp][b][s] = np.var(integral)
                                if norm is 'sum':
                                    integral -= np.min(integral)
                                    integral /= np.sum(integral)
                                elif norm is 'max':
                                    integral -= np.min(integral)
                                    integral /= np.max(integral)
                                hist[loc][t][g][v][sp][b][s] = integral
#                                else:
#                                    print 'Invalid Data @ Board%i,Sensor%i Gas:%i, Loc:%i, Trial:%i, Speed:%i, Voltage:%i' % \
#                                        (b_data, s_data, g_data, loc+1,
#                                         t_data, sp_data, v_data)
#                                    continue

    if pool:
        p_hist = np.zeros([6, num_bands])
        collection = [[] for i in range(6)]  # collection of all band integrals in scope
        p_std = np.zeros([6, num_bands])
        p_var = np.zeros([6, num_bands])
        p_mean = np.zeros([6, num_bands])
        for loc in xrange(6):
            for t in xrange(len(trial)):
                for g in xrange(len(gas)):
                    for v in xrange(len(voltage)):
                        for sp in xrange(len(speed)):
                            n = len(board) * len(sensor)
                            for b in xrange(len(board)):
                                for s in xrange(len(sensor)):
#                                    if all(hist[loc][t][g][v][sp][b][s]==0):
#                                        n -= 1
#                                        continue
                                    p_hist[loc] += hist[loc][t][g][v][sp][b][s]
                                    collection[loc].append(hist[loc][t][g][v][sp][b][s])
                            if norm is 'colsum':
                                p_hist[loc] -= np.min(p_hist[loc])
                                p_hist[loc] /= np.sum(p_hist[loc])
                                for i, c in enumerate(collection[loc]):
                                    c -= np.min(p_hist[loc])
                                    c /= np.sum(p_hist[loc])
                            elif norm is 'colmax':
                                p_hist[loc] -= np.min(p_hist[loc])
                                p_hist[loc] /= np.max(p_hist[loc])
                                for i, c in enumerate(collection[loc]):
                                    c -= np.min(p_hist[loc])
                                    c /= np.max(p_hist[loc])
                            p_hist[loc] /= float(n)
                        p_hist[loc] /= float(len(speed))
                    p_hist[loc] /= float(len(voltage))
                p_hist[loc] /= float(len(gas))
            p_hist[loc] /= float(len(trial))
            tmp = np.vstack(collection[loc])
            p_std[loc] = np.std(tmp, axis = 0)
            p_var[loc] = np.var(tmp, axis = 0)
            p_mean[loc] = np.mean(tmp, axis = 0)


        return p_hist, p_std, p_mean, p_var
    else:
        return hist, std, mean, var



class DataSelector:

    GasNames = {  # gas_conc(ppm)
        1: 'Acetaldehyde_500',
        2: 'Acetone_2500',
        3: 'Ammonia_10000',
        4: 'Benzene_200',
        5: 'Butanol_100',
        6: 'CO_1000',
        7: 'CO_4000',
        8: 'Ethylene_500',
        9: 'Methane_1000',
        10: 'Methanol_200',
        11: 'Toluene_200'}

    Locs = {
        1: 'L1',  # 0.25m
        2: 'L2',  # 0.50m
        3: 'L3',  # 0.98m
        4: 'L4',  # 1.18m
        5: 'L5',  # 1.40m
        6: 'L6'}  # 1.45m

    AltLocs = {  # redundant encoding of board location in file name.
        1: '1',  # closest to source
        2: '3',
        3: '5',
        4: '7',
        5: '9',
        6: '11'}  # farthest from source

    SensorVoltages = {
        1: '400V',  # 4.0V
        2: '450V',  # 4.5V
        3: '500V',  # 5.0V
        4: '550V',  # 5.5V
        5: '600V'}  # 6.0V

    FanSpeeds = {
        1: '000',   # 1500rpm
        2: '060',   # 3900rpm
        3: '100'}   # 5500rpm

    AltFanSpeeds = {
        1: '1500rpm',
        2: '3900rpm',
        3: '5500rpm'}

    def __init__(self, path,
                 drop_duplicates=True,
                 fill_gaps=True,
                 resample=True,
                 verbose=False,
                 cache_in_HDF=False):
         
        if not os.path.exists(path):
            raise(Exception('Error locating parent data path!'))
        else:
            self.parentDir = path
            if cache_in_HDF:
                HDFcache = os.path.join(path, '.HDFcache')
            else: 
                HDFcache = None
            self._args = {'verbose': verbose,
                          'drop_duplicates': drop_duplicates,
                          'resample': resample,
                          'fill_gaps': fill_gaps,
                          'HDFcache': HDFcache}
            if verbose:
                print 'DataMapper initialized with %s!' % path

    def select(self, gas=range(1, 12), loc=range(1, 7),
               voltage=range(1, 6), speed=range(1, 4), trial=range(1,21)):
        """
         Return all filepaths matching input constraints

         Keyword arguments:
         gas -- int of range(1,12), gas name identifier
         loc -- int of range(1,7) , sensor array column number
         voltage -- int of range(1,6) , sensor voltage identifier
         speed -- int of range(1,4) , fan speed identifier
         trial -- int of range(1,21), experiment repetitions
        """
        # cast int entries to list
        if isinstance(gas, int):
            gas = [gas]
        if isinstance(loc, int):
            loc = [loc]
        if isinstance(voltage, int):
            voltage = [voltage]
        if isinstance(speed, int):
            speed = [speed]
        if isinstance(trial,int):
            trial = [trial]

        # validate input
        assert min(gas) > 0 and max(gas) in self.GasNames.keys(), \
            'Wrong gas name!'
        assert min(loc) > 0 and max(loc) in self.Locs.keys(), \
            'Wrong board location!'
        assert min(voltage) > 0 and max(voltage) in self.SensorVoltages.keys(), \
            'Wrong sensor voltage!'
        assert min(speed) > 0 and max(speed) in self.FanSpeeds.keys(), \
            'Wrong fan speed!'
        assert min(trial) > 0 and max(trial) in range(1,21), \
            'Selected none existing trial number!'
        assert hasattr(self, 'parentDir'), \
            'Missing parent directory!'

        cols = []  # build a list of initialized SensorColumn objects
        for g in gas:
            for l in loc:
                sub = os.path.join(
                    self.parentDir, self.GasNames[g], self.Locs[l])
                try:
                    files = os.listdir(sub)
                    files.sort()
                except OSError, e:
                    print("{}\n Keeping calm and carrying on.".format(e))
                    continue
                for v in voltage:
                    for s in speed:
                        end = "_board_setPoint_%s_fan_setPoint_%s_mfc_setPoint_%sppm_p%s" % (
                            self.SensorVoltages[v],
                            self.FanSpeeds[s],
                            self.GasNames[g],
                            self.AltLocs[l])
                        filtered = [f for f in files if f.endswith(end)]
                        if not filtered:
                            if self._args['verbose']:
                                print 'No valid files found for "%s", skipping!' % \
                                    sub
                            continue
                        timeStamp = [filt.split('_', 1)[0] for filt in filtered]
                        date = [time.strptime(ts, '%Y%m%d%H%M') for ts in timeStamp]
                        date = [time.strftime('%Y-%m-%d %H:%M', d) for d in date]
                        filtered = [os.path.join(sub, f) for f in filtered]
                        for i, filt in enumerate(filtered):
                            j = i + 1
                            if j in trial:
                                cols.append(
                                    SensorColumn(
                                        filename=filt,
                                        date=date[i],
                                        gas=self.GasNames[g],
                                        loc=self.Locs[l],
                                        voltage=self.SensorVoltages[v],
                                        speed=self.AltFanSpeeds[s],
                                        trial=j,
                                        _args=self._args))

        if self._args['verbose']:
            print '\nSelected %i single trial SensorColumns!' % \
                len(cols)
        return cols

