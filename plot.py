# -*- coding: utf-8 -*-
"""
Created on Tue Aug 19 14:31:57 2014

@author: viktor

plumy.plot - Plumy's visualization module.
 
"""

from plumy.utils import DataSelector 
from matplotlib import pyplot as plt
from matplotlib.ticker import AutoMinorLocator
import numpy as np
import scipy as sp

def plot(obj, mode='default', show_mfc_read=False, 
         show_title=True, show_legend=True):
    """
    Plot time series.
    Returns figure handle and plot title.
    
    Keyword arguments:
    obj -- SensorColumn, SensorBoard or Sensor class instance
    mode -- string, plot mode
    show_title -- bool, display Title on/off
    show_legend -- bool, display legend on/off
    
    Available modes:
    SensorColumn -- 'default', 'norm' (normalized), 'filt' (filtered)
    SensorBoard -- 'default', 'norm', 'filt', 'aio' (all-in-one), 'norm_aio', 'filt_aio', 'norm_filt'
    Sensor -- 'default', 'norm' (normalized), 'filt' (filtered), 'norm_filt'
    """
    assert isinstance(mode, str)
    assert isinstance(show_title, bool)
    assert isinstance(show_legend, bool)

    fig = plt.figure()
    title = '%s: %s %s %s %s %s' % (obj.Name, obj.Gas, obj.Location,
                                    obj.SensorVoltage, obj.FanSpeed,
                                    obj.TimeStamp)
    if show_title:
        fig.suptitle(title, fontsize=16)

    if obj.__class__.__name__ is 'SensorColumn':
        x = obj._Time  # ms

        if show_mfc_read:
            first = []
            last = []
            try:
                first.append(np.where(obj.get_mfc1_read>=100)[0][0])
                last.append(np.where(obj.get_mfc1_read>=100)[0][-1])
            except:
                pass
            try:
                first.append(np.where(obj.get_mfc2_read>=100)[0][0])
                last.append(np.where(obj.get_mfc2_read>=100)[0][-1])
            except:
                pass
            try:
                first.append(np.where(obj.get_mfc3_read>=100)[0][0])
                last.append(np.where(obj.get_mfc3_read>=100)[0][-1])
            except:
                pass

            if not first or not last:
                print 'No MFC reads present!'
                return
            else:
                first = obj._Time[min(first)]/1000
                last = obj._Time[max(last)]/1000

        if mode is 'default':
            xlim = [0, 260000]            
            ylim = [obj.get_min()[2], obj.get_max()[2]]
            
            for i in xrange(1,10):
                fig.add_subplot(3,3,i)
                board = getattr(obj, 'Board%i' % (i))
                lines = plt.plot(x, board())
            
                if i is 1 and show_legend:
                    fig.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                               'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=8,
                               mode = 'expand', ncol=8)
                
                locs, labels = plt.xticks()
                labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                
                plt.title('Board %i' % i)
                if show_mfc_read:
                    plt.axvspan(first, last,
                                facecolor= 'g', alpha = 0.5)
                plt.grid()

            plt.tight_layout()
            try:
                mng = plt.get_current_fig_manager()
                mng.window.showMaximized()
            except AttributeError:
                pass
            plt.show()
                
        elif mode is 'norm':
            xlim = [0, 260000]
            ylim = [0, 1]
            
            for i in xrange(1,10):
                fig.add_subplot(3,3,i)
                board = getattr(obj, 'Board%i' % (i))
                lines = plt.plot(x, board.get_normal)
            
                if i is 1 and show_legend:
                    fig.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                               'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=8,
                               mode = 'expand', ncol=8)
                locs, labels = plt.xticks()
                labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                plt.title('Board %i')
                if show_mfc_read:
                    plt.axvspan(first, last,
                                facecolor= 'g', alpha = 0.5)
                plt.grid()
                
            plt.tight_layout()
            try:
                mng = plt.get_current_fig_manager()
                mng.window.showMaximized()
            except AttributeError:
                pass
            plt.show()

        if mode is 'filt':

            for i in xrange(1,10):
                fig.add_subplot(3,3,i)
                board = getattr(obj, 'Board%i' % (i))
                lines = plt.plot(x, board.get_filtered, linewidth=2)
            
                if i is 1 and show_legend:
                    fig.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                               'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=8,
                               mode = 'expand', ncol=8)
                locs, labels = plt.xticks()
                labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim([0, 260000])
                plt.ylim([obj.get_min()[2], obj.get_max()[2]])
                plt.title('Board %i' % (i))
                if show_mfc_read:
                    plt.axvspan(first, last,
                                facecolor= 'g', alpha = 0.5)
                plt.grid()

            plt.tight_layout()
            try:
                mng = plt.get_current_fig_manager()
                mng.window.showMaximized()
            except AttributeError:
                pass
            plt.show()

    elif obj.__class__.__name__ is 'SensorBoard':
        x = obj._Time  # ms
        if mode is 'default':
            xlim = [0, 260000]
            ylim = [obj.get_min[1], obj.get_max[1]]
            for i in xrange(1,9):
                fig.add_subplot(2,4,i)
                sensor = getattr(obj, 'Sensor%i' % (i))
                plt.plot(x, sensor(), label= 'Sensor %i' % (i), c = 'r')
                plt.title('Sensor %i' % (i))
            
                if i is 1:
                    locs, labels = plt.xticks()
                    labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                plt.grid()

        elif mode is 'norm':
            xlim = [0, 260000]
            ylim = [0, 1]
            for i in xrange(1,9):
                fig.add_subplot(2,4,i)
                sensor = getattr(obj, 'Sensor%i' % (i))
                plt.plot(x, sensor.get_normal, label= 'Sensor %i' % (i), c = 'r')
                plt.title('Sensor %i' % (i))
            
                if i is 1:
                    locs, labels = plt.xticks()
                    labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                plt.grid()
                
        elif mode is 'filt':
            xlim = [0, 260000]
            ylim = [obj.get_min[1], obj.get_max[1]]
            for i in xrange(1,9):
                fig.add_subplot(2,4,i)
                sensor = getattr(obj, 'Sensor%i' % (i))
                plt.plot(x, sensor.get_filtered, label= 'Sensor %i' % (i), c = 'r')
                plt.title('Sensor %i' % (i))
            
                if i is 1:
                    locs, labels = plt.xticks()
                    labels = np.linspace(0,300,7)
                plt.xticks(locs, labels)
            
                plt.xlim(xlim)
                plt.ylim(ylim)
                plt.grid()
                
        elif mode is 'aio':
            lines = plt.plot(x, obj())
            if show_legend:
                plt.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                           'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=6)
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([obj.get_min[1], obj.get_max[1]])
            if show_title:
                plt.title('All raw Sensors')
            plt.grid()
            
        elif mode in ['aio_norm','norm_aio']:
            lines = plt.plot(x, obj.get_normal)
            if show_legend:
                plt.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                           'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=6)
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([0,1])
            if show_title:
                plt.title('All Sensors normalized')
            plt.grid()
            
        elif mode in ['aio_filt', 'filt_aio']:
            lines = plt.plot(x, obj.get_filtered, linewidth=2)
            if show_legend:
                plt.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                           'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=6)
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([obj.get_min[1], obj.get_max[1]])
            if show_title:            
                plt.title('All Sensors Low-Pass filtered')
            plt.grid()
            
        elif mode in ['norm_filt','filt_norm']:
            y = obj.normalize(obj.get_filtered, obj.get_min[1], obj.get_max[1])
            lines = plt.plot(x, y, linewidth=2)
            if show_legend:
                plt.legend(iter(lines), ('Sensor 1','Sensor 2','Sensor 3','Sensor 4',
                           'Sensor 5','Sensor 6','Sensor 7','Sensor 8'), loc=6)
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([0, 1])
            if show_title:            
                plt.title('All Sensors normalized & Low-Pass filtered')
            plt.grid()
            
        else:
            print 'No Option %s found!' % mode

    elif obj.__class__.__name__ is 'Sensor':
        x = obj._Time  # ms
        if mode is 'default':
            plt.plot(x, obj(), c = 'r')
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([obj.get_min, obj.get_max])
            plt.grid()
        elif mode is 'norm':
            plt.plot(x, obj.get_normal, c = 'r')
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([0,1])
            plt.grid()
        elif mode is 'filt':
            plt.plot(x, obj.get_filtered, c = 'r')
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([obj.get_min, obj.get_max])
            plt.grid()
        elif mode in ['norm_filt','filt_norm']:
            y = obj.normalize(obj.get_filtered, obj.get_min, obj.get_max)
            plt.plot(x, y, c = 'r')
            locs, labels = plt.xticks()
            labels = np.linspace(0,300,7)
            plt.xticks(locs, labels)
            plt.xlim([0, 260000])
            plt.ylim([0,1])
            plt.grid()
        else:
            print 'No Option %s found!' % mode
    return fig, title
    
def activity(ds, **kwargs):
    """
    Plot testbed (all 6 Columns) activity.
    Returns figure & colorbar handle.
    
    Keyword arguments:
    gas -- int of range(1,12), gas name identifier
    voltage -- int of range(1,6) , sensor voltage identifier
    speed -- int of range(1,4) , fan speed identifier
    trial -- int of range(1,21), experiment repetitions
    mode -- string, activity criterion    
    
    Available modes:
    'max' -- Use Sensor activation maxima as criterion
    'var' -- Use Sensor variability as criterion
    'fano' -- Use fano-factor (Variance/Mean) as criterion
    """
    assert isinstance(ds, DataSelector)
    
    default_gas = 10
    default_voltage = 5
    default_speed = 1
    default_trial = 1
    default_mode = 'max'

    gas = kwargs.get('gas', default_gas)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)
    mode = kwargs.get('mode', default_mode)      
    
    assert isinstance(gas, int) and gas in range(1,12)
    assert isinstance(voltage, int) and voltage in range(1,6)
    assert isinstance(speed, int) and speed in range(1,4)
    assert isinstance(trial, int) and trial in range(1,21)
    assert mode in ['var', 'max', 'fano']
    
    col = ds.select(gas=gas, voltage=voltage, speed=speed, trial=trial)
    
    fig = plt.figure()
    gs = plt.GridSpec(9,6)
    _max = 0
    
    if mode is 'max':
        for c in col:
            if c.get_max()[2] > _max:
                _max = c.get_max()[2]
    elif mode is 'var':
        for c in col:
            if c.get_var()[2] > _max:
                _max = c.get_var()[2]
    elif mode is 'fano':
        for c in col:
            if c.get_fano()[2] > _max:
                _max = c.get_fano()[2]   
    
    for i,column in enumerate(col):
        for j,board in enumerate(column.iter_boards):
            plt.subplot(gs[j,i])
            arr = []
            for sensor in board.iter_sensors:
                if mode is 'max':
                    arr.append(sensor.get_max)
                elif mode is 'var':
                    arr.append(sensor.get_var)
                elif mode is 'fano':
                    arr.append(sensor.get_fano)
                
            arr = np.array(arr)
            arr.shape = (2,4)
            ax = plt.imshow(arr, interpolation='nearest', vmax=_max)
            plt.axis('off')
    
    fig.subplots_adjust(right=0.8)
    cbar_ax = fig.add_axes([0.85, 0.15, 0.025, 0.7])
    cb = fig.colorbar(ax, cax=cbar_ax)
    try:
        mng = plt.get_current_fig_manager()
        mng.window.showMaximized()
    except AttributeError:
        pass
    plt.show()
    return fig, cb
    
def spectral(ds, **kwargs):
    """
    Plot selected comparative frequency spectra.
    Returns figure handle(s) and plot title(s); 
    If pool-flag is true, return compiled fft data aswell. 
    
    Keyword arguments:
    gas -- int or list of range(1,12), gas name identifier
    loc -- int or list of range(1,7), column location identifier
    voltage -- int of range(1,6) , sensor voltage identifier
    speed -- int of range(1,4) , fan speed identifier
    trial -- int of range(1,21), experiment repetitions
    board -- int or list of range(1,10), board identifier
    sensor -- int or list of range(1,9), sensor identifier
    pool -- bool, if true, compile all spectra into a single plot
    win -- slice, time series selection window
    """
    assert isinstance(ds, DataSelector)
    
    # set default values
    default_gas = 10
    default_loc = 1
    default_voltage = 5
    default_speed = 1
    default_trial = 1
    default_board = 4
    default_sensor = 5
    default_pool = False
    default_win = slice(10000, 20000)

    # get arguments
    gas = kwargs.get('gas', default_gas)
    loc = kwargs.get('loc', default_loc)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)    
    brd = kwargs.get('board', default_board)
    snsr = kwargs.get('sensor', default_sensor)
    pool = kwargs.get('pool', default_pool)
    win = kwargs.get('win', default_win)
    
    # assert argument datatype 
    assert isinstance(loc, (int, list))
    assert isinstance(gas, int)
    assert isinstance(voltage, int) 
    assert isinstance(speed, int) 
    assert isinstance(trial, int) 
    assert isinstance(brd, (int, list))
    assert isinstance(snsr, (int, list))
    assert isinstance(pool, bool)
    assert isinstance(win, slice)
    
    # cast int entries to list
    if isinstance(loc, int):
        loc = [loc]
    if isinstance(brd, int):
        brd = [brd]
    if isinstance(snsr, int):
        snsr = [snsr]
    
    # assert argument value
    assert min(loc) > 0 and max(loc) <= 6
    assert gas in range(1,12)
    assert voltage in range(1,6)
    assert speed in range(1,4)
    assert trial in range(1,21)
    assert min(brd) > 0 and max(brd) <= 9
    assert min(snsr) > 0 and max(snsr) <= 8
    assert win.start >= 0 and win.stop <= 26000
    
    # select columns
    cols = ds.select(gas=gas, loc=loc, speed=speed, voltage=voltage, trial=trial)
    
    rgb_tuples = plt.cm.spectral(np.arange(265)) # generate rgb color values
    lines = []
    b, a = sp.signal.butter(2, (float(0.01)/50, 1/float(50)), 'bandpass')    
    
    if pool:
        # allocate fft data storage
        fft_list = np.zeros([len(loc),len(brd)*len(snsr)+1,5000])
        cnt = 0
    else:
        handle_list = []
        title_list = []
        
    for bo in brd:
        for se in snsr:
            
            if not pool:
                # generate individual figure
                fig = plt.figure()
                handle_list.append(fig)
                title = '%s L1-L6 %s %s %s Board %i, Sensor %i' % (cols[0].Gas, cols[0].SensorVoltage,
                                       cols[0].FanSpeed, cols[0].TimeStamp, bo, se)
                title_list.append(title)
                fig.suptitle(title)
            else:
                # increment fft_list counter
                cnt += 1
                
            for i in xrange(len(loc)):
                x = cols[i]._Time[win]
                try:
                    # get board & sensor
                    board = getattr(cols[i], 'Board%i' % (bo))
                    sensor = getattr(board, 'Sensor%i' % (se))
                except:
                    print '-- Missing: L%i, Board %i, Sensor %i' % (i+1, bo, se)
                    continue
                if not sensor.is_valid:
                    print '-- Invalid: L%i, Board %i, Sensor %i' % (i+1, bo, se)
                    continue
                # calculate fft spectrum
                y = sensor()[win]
                y = sp.signal.filtfilt(b, a, y)
                fft = np.abs(np.fft.fft(y))
                frq = np.fft.fftfreq(len(x), 0.01)
                fft = fft[range(len(x)/2)]
                frq = frq[range(len(x)/2)]
                if not pool:
                    # plot fft data
                    ax = plt.subplot(111)
                    fft /= sum(fft)
                    line = plt.plot(frq, fft, color=rgb_tuples[i*45], linewidth=2)
                    lines.append(line[0])
                else:
                    # add data to list
                    fft_list[i][cnt] += fft
    
            if not pool:
                # add legend
                ax.legend(iter(lines), ['L%i'%(i) for i in loc], loc='center right')
                plt.xlim(0, 0.5)
                plt.ylim(0, 0.5)
                plt.xlabel('Frequency [Hz]')
                plt.ylabel('Power ratio [%]')
                # create custom minor ticks
                locator = AutoMinorLocator()
                ax.xaxis.set_minor_locator(locator)
                ax.tick_params(axis='x',which='minor')
                ax.grid(which='both')
                plt.show()
                
    if pool:
        # create pooled figure
        fig = plt.figure()
        title = '%s L1-L6 %s %s, %i boards, %i sensors' % (cols[0].Gas, cols[0].SensorVoltage,
                                       cols[0].FanSpeed, len(brd), len(snsr))
        fig.suptitle(title)
        sum_fft_list = np.zeros([len(loc),5000])
        std_fft_list = np.zeros([len(loc),5000])
        for i in xrange(len(loc)):
            ax = plt.subplot(111)
            for j in xrange(1,np.shape(fft_list)[1]):
                sum_fft_list[i] += fft_list[i][j]
            std_fft_list = np.std(fft_list[i],axis=0) / sum(sum_fft_list[i])
            sum_fft_list[i] /= sum(sum_fft_list[i])
            line = plt.plot(frq, sum_fft_list[i], color=rgb_tuples[i*45], linewidth=2)
            plt.errorbar(frq, sum_fft_list[i], yerr=std_fft_list, color=rgb_tuples[i*45])
            lines.append(line[0])
        ax.legend(iter(lines), ['L%i'%(i) for i in loc], loc='center right')
        plt.xlim(0, 0.5)
        plt.ylim(0, 0.25)
        plt.xlabel('Frequency [Hz]')
        plt.ylabel('Power ratio [%]')
        locator = AutoMinorLocator()
        ax.xaxis.set_minor_locator(locator)
        ax.tick_params(axis='x',which='minor')
        ax.grid(which='both')
        plt.show()    
        return fig, title, sum_fft_list, std_fft_list
    else:
        return handle_list, title_list
        
def power_distrib(ds, **kwargs):
    """
    Plot distribution of power ratio over frequency range.
    Returns figure handle and compiled fft data. 
    
    Keyword arguments:
    gas -- int or list of range(1,12), gas name identifier
    loc -- int or list of range(1,7), column location identifier
    voltage -- int or list of range(1,6) , sensor voltage identifier
    speed -- int or list of range(1,4) , fan speed identifier
    trial -- int or list of range(1,21), experiment repetitions
    board -- int or list of range(1,10), board identifier
    sensor -- int or list of range(1,9), sensor identifier
    pool -- bool, if true, compile all spectra into a single plot
    win -- slice, time series selection window
    """
    
    assert isinstance(ds, DataSelector)
    
    # set default values
    default_gas = xrange(1,12)
    default_loc = xrange(1,7)
    default_voltage = 5
    default_speed = 1
    default_trial = xrange(1,21)
    default_board = xrange(1,10)
    default_sensor = xrange(1,9)
    default_win = slice(10000, 20000)

    # get arguments
    gas = kwargs.get('gas', default_gas)
    loc = kwargs.get('loc', default_loc)
    voltage = kwargs.get('voltage', default_voltage)
    speed = kwargs.get('speed', default_speed)
    trial = kwargs.get('trial', default_trial)    
    brd = kwargs.get('board', default_board)
    snsr = kwargs.get('sensor', default_sensor)
    win = kwargs.get('win', default_win)
    
    # assert argument datatype 
    assert isinstance(gas, (int, list))
    assert isinstance(loc, (int, list))
    assert isinstance(voltage, (int, list)) 
    assert isinstance(speed, (int, list)) 
    assert isinstance(trial, (int, list)) 
    assert isinstance(brd, (int, list))
    assert isinstance(snsr, (int, list))
    assert isinstance(win, slice)
    
    # cast int entries to list
    if isinstance(gas, int):
        gas = [gas]
    if isinstance(loc, int):
        loc = [loc]
    if isinstance(voltage, int):
        voltage = [voltage]
    if isinstance(speed, int):
        speed = [speed]
    if isinstance(trial,int):
        trial = [trial]
    if isinstance(brd, int):
        brd = [brd]
    if isinstance(snsr, int):
        snsr = [snsr]
    
    # assert argument value
    assert min(gas) > 0 and max(gas) <= 11
    assert min(loc) > 0 and max(loc) <= 6
    assert min(voltage) > 0 and max(voltage) <= 5
    assert min(speed) > 0 and max(speed) <= 3
    assert min(trial) > 0 and max(trial) <= 20
    assert min(brd) > 0 and max(brd) <= 9
    assert min(snsr) > 0 and max(snsr) <= 8
    assert win.start >= 0 and win.stop <= 26000
    
    b, a = sp.signal.butter(2, (float(0.01)/50, 1/float(50)), 'bandpass')
    fft_hist = np.zeros((win.stop-win.start)/2)
    cnt = 0
    
    # iterate over all parameters
    for g in gas:
        for l in loc:
            for s in speed:
                for v in voltage:
                    for t in trial:
                        try:
                            # try to get column
                            cols = ds.select(gas = g, loc = l, voltage = v, \
                            speed = s, trial = t)
                            cnt += 1
                            x = cols[0]._Time[win]
                        except:
                            print '-- Missing: Gas %i, L%i, Trial %i' % (g, l, t)
                            continue
                        for bo in brd:
                            try:
                                # get board
                                board = getattr(cols[0], 'Board%i' % (bo))
                            except:
                                print '-- Missing: Gas %i, L%i, %s, %s, Trial %i, Board %i' % \
                                (g, l, ds.AltFanSpeeds[s], ds.SensorVoltages[v], t, bo)
                                continue
                            for se in snsr:
                                # get sensor
                                sensor = getattr(board, 'Sensor%i' % (se))
                                if sensor.is_valid:
                                    # fourier transform 
                                    y = sensor()[win]
                                    y = sp.signal.filtfilt(b, a, y)
                                    fft = np.abs(np.fft.fft(y))
                                    fft = fft[range(len(x)/2)]
                                    # pool data
                                    fft_hist += fft

    # normalize pooled data
    fft_hist /= sum(fft_hist)
    # calculate frequencies
    frq = np.fft.fftfreq(len(x), 0.01)
    frq = frq[range(len(x)/2)]
    
    fig = plt.figure()
    ax = fig.add_subplot(111)
    plt.plot(frq, fft_hist, 'k')
    plt.fill_between(frq, fft_hist, color = 'gray')
    # TODO: Implement xlim & ylim as input variables.
    plt.xlim(0.0, 0.5)
    plt.ylim(0.0, 0.25)
    # create custom minor ticks
    locator = AutoMinorLocator()
    ax.xaxis.set_minor_locator(locator)
    ax.tick_params(axis='x',which='minor')
    ax.grid(which='both')
    
    plt.xlabel('Frequency [Hz]')
    plt.ylabel('Power ratio')
    # calculate amount of power in dsiplayed range
    pwr = np.round(sum(fft_hist[range(0,50)])*100, decimals=2)
    # plt.text(0.15, 0.2, '%s %% of total Power' % (pwr), fontsize=12)
    print 'The displayed range contains %s %% of the total power' % (pwr)
    print '%i Columns' % cnt

    try:
        mng = plt.get_current_fig_manager()
        mng.window.showMaximized()
    except AttributeError:
        pass
    plt.show()
    return fig, fft_hist                          
     
    
